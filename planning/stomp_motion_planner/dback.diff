Index: include/stomp_motion_planner/stomp_planner_node.h
===================================================================
--- include/stomp_motion_planner/stomp_planner_node.h	(.../cturtle/stomp_motion_planner)	(revision 50636)
+++ include/stomp_motion_planner/stomp_planner_node.h	(.../diamondback/stomp_motion_planner)	(revision 50636)
@@ -111,6 +111,9 @@
   ros::Publisher vis_marker_array_publisher_;           /**< Publisher for marker arrays */
   ros::Publisher vis_marker_publisher_;                 /**< Publisher for markers */
   std::map<std::string, double> joint_velocity_limits_; /**< Map of joints to velocity limits */
+  bool use_trajectory_filter_;
+  int maximum_spline_points_;
+  int minimum_spline_points_;
 
   std::map<std::string, motion_planning_msgs::JointLimits> joint_limits_;
   void getLimits(const trajectory_msgs::JointTrajectory& trajectory, 
Index: include/stomp_motion_planner/stomp_robot_model.h
===================================================================
--- include/stomp_motion_planner/stomp_robot_model.h	(.../cturtle/stomp_motion_planner)	(revision 50636)
+++ include/stomp_motion_planner/stomp_robot_model.h	(.../diamondback/stomp_motion_planner)	(revision 50636)
@@ -205,6 +205,8 @@
   void generateLinkCollisionPoints();
   void populatePlanningGroupCollisionPoints();
 
+  void publishCollisionPoints(ros::Publisher& vis_marker);
+
 private:
   ros::NodeHandle node_handle_,root_handle_;                                 /**< ROS Node handle */
   planning_environment::CollisionSpaceMonitor* monitor_;
@@ -225,7 +227,7 @@
   double max_radius_clearance_;                                 /**< Maximum value of radius + clearance for any of the collision points */
   std::map<std::string, mapping_msgs::AttachedCollisionObject> attached_objects_;        /**< Map of links -> attached objects */
 
-  void addCollisionPointsFromLinkRadius(std::string link_name, double radius, double clearance, double extension);
+  void addCollisionPointsFromLink(const planning_models::KinematicState& state, std::string link_name, double clearance);
   //void addCollisionPointsFromAttachedObject(std::string link_name, mapping_msgs::AttachedCollisionObject& attached_object);
   void getLinkInformation(const std::string link_name, std::vector<int>& active_joints, int& segment_number);
 
Index: include/stomp_motion_planner/stomp_collision_space.h
===================================================================
--- include/stomp_motion_planner/stomp_collision_space.h	(.../cturtle/stomp_motion_planner)	(revision 50636)
+++ include/stomp_motion_planner/stomp_collision_space.h	(.../diamondback/stomp_motion_planner)	(revision 50636)
@@ -169,13 +169,14 @@
   planning_environment::CollisionModels* collision_models_;
 
   void loadRobotBodies();
-  void updateRobotBodiesPoses();
+  void updateRobotBodiesPoses(const planning_models::KinematicState& state);
   void getVoxelsInBody(const bodies::Body &body, std::vector<btVector3> &voxels);
-  void addCollisionObjectsToPoints(std::vector<btVector3>& points);
+  void addCollisionObjectsToPoints(std::vector<btVector3>& points, const btTransform& cur);
   void addBodiesInGroupToPoints(const std::string& group, std::vector<btVector3> &voxels);
   void addAllBodiesButExcludeLinksToPoints(std::string group_name, std::vector<btVector3>& body_points);  
 
   std::map<std::string, std::vector<std::string> > distance_exclude_links_;
+  std::map<std::string, std::vector<std::string> > distance_include_links_;
 
 };
 
Index: include/stomp_motion_planner/stomp_trajectory.h
===================================================================
--- include/stomp_motion_planner/stomp_trajectory.h	(.../cturtle/stomp_motion_planner)	(revision 50636)
+++ include/stomp_motion_planner/stomp_trajectory.h	(.../diamondback/stomp_motion_planner)	(revision 50636)
@@ -90,6 +90,8 @@
 
   Eigen::MatrixXd::ColXpr getJointTrajectory(int joint);
 
+  void overwriteTrajectory(const trajectory_msgs::JointTrajectory& traj);
+
   /**
    * \brief Gets the number of points in the trajectory
    */
@@ -143,12 +145,12 @@
   /**
    * \brief Gets the block of the trajectory which can be optimized
    */
-  Eigen::BlockReturnType<Eigen::MatrixXd>::Type getFreeTrajectoryBlock();
+  Eigen::Block<Eigen::MatrixXd, Eigen::Dynamic, Eigen::Dynamic>  getFreeTrajectoryBlock();
 
   /**
    * \brief Gets the block of free (optimizable) trajectory for a single joint
    */
-  Eigen::BlockReturnType<Eigen::MatrixXd>::Type getFreeJointTrajectoryBlock(int joint);
+  Eigen::Block<Eigen::MatrixXd, Eigen::Dynamic, Eigen::Dynamic> getFreeJointTrajectoryBlock(int joint);
 
   /**
    * \brief Updates the full trajectory (*this) from the group trajectory
@@ -166,6 +168,8 @@
   template <typename Derived>
   void getJointVelocities(int traj_point, Eigen::MatrixBase<Derived>& velocities);
 
+  double getDuration() const;
+
 private:
 
   void init();                                          /**< \brief Allocates memory for the trajectory */
@@ -245,12 +249,12 @@
   return trajectory_;
 }
 
-inline Eigen::BlockReturnType<Eigen::MatrixXd>::Type ChompTrajectory::getFreeTrajectoryBlock()
+inline Eigen::Block<Eigen::MatrixXd, Eigen::Dynamic, Eigen::Dynamic> ChompTrajectory::getFreeTrajectoryBlock()
 {
   return trajectory_.block(start_index_, 0, getNumFreePoints(), getNumJoints());
 }
 
-inline Eigen::BlockReturnType<Eigen::MatrixXd>::Type ChompTrajectory::getFreeJointTrajectoryBlock(int joint)
+inline Eigen::Block<Eigen::MatrixXd, Eigen::Dynamic, Eigen::Dynamic> ChompTrajectory::getFreeJointTrajectoryBlock(int joint)
 {
   return trajectory_.block(start_index_, joint, getNumFreePoints(), 1);
 }
@@ -278,6 +282,9 @@
   }
 }
 
+inline double ChompTrajectory::getDuration() const {
+  return duration_;
+}
 
 }
 
Index: manifest.xml
===================================================================
--- manifest.xml	(.../cturtle/stomp_motion_planner)	(revision 50636)
+++ manifest.xml	(.../diamondback/stomp_motion_planner)	(revision 50636)
@@ -6,7 +6,7 @@
 please refer to:
 
 "CHOMP: Gradient Optimization Techniques for Efficient Motion Planning".
-Nathan Ratliff, Matthew Zucker, J. Andrew Bagnell anhd Siddhartha Srinivasa.
+Nathan Ratliff, Matthew Zucker, J. Andrew Bagnell and Siddhartha Srinivasa.
 IEEE International Conference on Robotics and Automation, May 2009. 
 
   </description>
Index: src/stomp_optimizer.cpp
===================================================================
--- src/stomp_optimizer.cpp	(.../cturtle/stomp_motion_planner)	(revision 50636)
+++ src/stomp_optimizer.cpp	(.../diamondback/stomp_motion_planner)	(revision 50636)
@@ -173,11 +173,15 @@
 
 void ChompOptimizer::optimize()
 {
+  ros::WallTime start_time = ros::WallTime::now();
+
   collision_space_->lock();
 
-  animatePath();
+  if (parameters_->getAnimatePath())
+  {
+    animatePath();
+  }
 
-  ros::WallTime start_time = ros::WallTime::now();
   // iterate
   for (iteration_=0; iteration_<parameters_->getMaxIterations(); iteration_++)
   {
@@ -267,15 +271,16 @@
   {
     animatePath();
   }
-
+  
   group_trajectory_.getTrajectory() = best_group_trajectory_;
   updateFullTrajectory();
-  ROS_INFO("Terminated after %d iterations, using path from iteration %d", iteration_, last_improvement_iteration_);
-  ROS_INFO("Optimization core finished in %f sec", (ros::WallTime::now() - start_time).toSec());
 
   collision_space_->unlock();
   if (parameters_->getAnimatePath())
     animatePath();
+
+  ROS_INFO("Terminated after %d iterations, using path from iteration %d", iteration_, last_improvement_iteration_);
+  ROS_INFO("Optimization core finished in %f sec", (ros::WallTime::now() - start_time).toSec());
 }
 
 void ChompOptimizer::calculateSmoothnessIncrements()
Index: src/stomp_planner_node.cpp
===================================================================
--- src/stomp_planner_node.cpp	(.../cturtle/stomp_motion_planner)	(revision 50636)
+++ src/stomp_planner_node.cpp	(.../diamondback/stomp_motion_planner)	(revision 50636)
@@ -32,7 +32,7 @@
  *  POSSIBILITY OF SUCH DAMAGE.
  *********************************************************************/
 
-/** \author Mrinal Kalakrishnan */
+/** \author Mrinal Kalakrishnan, E. Gil Jones */
 
 #include <stomp_motion_planner/stomp_planner_node.h>
 #include <stomp_motion_planner/stomp_trajectory.h>
@@ -43,6 +43,7 @@
 #include <angles/angles.h>
 #include <visualization_msgs/MarkerArray.h>
 #include <spline_smoother/cubic_trajectory.h>
+#include <motion_planning_msgs/FilterJointTrajectory.h>
 
 #include <map>
 #include <vector>
@@ -62,10 +63,29 @@
 bool ChompPlannerNode::init()
 {
   // load in some default parameters
-  node_handle_.param("reference_frame", reference_frame_, std::string("base_link"));
   node_handle_.param("trajectory_duration", trajectory_duration_, 3.0);
   node_handle_.param("trajectory_discretization", trajectory_discretization_, 0.03);
+  node_handle_.param("use_additional_trajectory_filter", use_trajectory_filter_, true);
+  node_handle_.param("minimum_spline_points", minimum_spline_points_, 40);
+  node_handle_.param("maximum_spline_points", maximum_spline_points_, 100);
 
+  if(node_handle_.hasParam("joint_velocity_limits")) {
+    XmlRpc::XmlRpcValue velocity_limits;
+    
+    node_handle_.getParam("joint_velocity_limits", velocity_limits);
+
+    if(velocity_limits.getType() ==  XmlRpc::XmlRpcValue::TypeStruct) {
+      if(velocity_limits.size() > 0) {
+        for(XmlRpc::XmlRpcValue::iterator it = velocity_limits.begin();
+            it != velocity_limits.end();
+            it++) {
+          joint_velocity_limits_[it->first] = it->second;
+          ROS_DEBUG_STREAM("Vel limit for " << it->first << " is " << joint_velocity_limits_[it->first]);
+        }
+      }
+    }  
+  } 
+
   //filter_constraints_chain_.configure("filter_chain",node_handle_);
 
   collision_models_ = new planning_environment::CollisionModels("robot_description");
@@ -75,12 +95,14 @@
     return false;
   }
 
-  monitor_ = new planning_environment::CollisionSpaceMonitor(collision_models_, &tf_, reference_frame_);
+  monitor_ = new planning_environment::CollisionSpaceMonitor(collision_models_, &tf_);
 
-  filter_trajectory_client_ = node_handle_.serviceClient<motion_planning_msgs::FilterJointTrajectoryWithConstraints>("trajectory_filter/filter_trajectory_with_constraints",true);    
-  
-  ros::service::waitForService("trajectory_filter/filter_trajectory_with_constraints");
+  monitor_->waitForState();
+  monitor_->setUseCollisionMap(true);
+  monitor_->startEnvironmentMonitor();
 
+  reference_frame_ = monitor_->getRobotFrameId();
+
   // build the robot model
   if (!stomp_robot_model_.init(monitor_, reference_frame_))
     return false;
@@ -101,8 +123,14 @@
   // advertise the planning service
   plan_kinematic_path_service_ = root_handle_.advertiseService("stomp_planner_longrange/plan_path", &ChompPlannerNode::planKinematicPath, this);
 
-  filter_joint_trajectory_service_ = root_handle_.advertiseService("stomp_planner_longrange/filter_trajectory", &ChompPlannerNode::filterJointTrajectory, this);
+  filter_joint_trajectory_service_ = root_handle_.advertiseService("stomp_planner_longrange/filter_trajectory_with_constraints", &ChompPlannerNode::filterJointTrajectory, this);
 
+  if(use_trajectory_filter_) {
+    filter_trajectory_client_ = root_handle_.serviceClient<motion_planning_msgs::FilterJointTrajectoryWithConstraints>("trajectory_filter/filter_trajectory_with_constraints");    
+  
+    ros::service::waitForService("trajectory_filter/filter_trajectory_with_constraints");
+  }
+
   ROS_INFO("Initalized STOMP planning service...");
 
   return true;
@@ -159,6 +187,8 @@
   // set the start state:
   stomp_robot_model_.jointStateToArray(req.motion_plan_request.start_state.joint_state, trajectory.getTrajectoryPoint(0));
 
+  ROS_INFO_STREAM("Joint state has " << req.motion_plan_request.start_state.joint_state.name.size() << " joints");
+
   //configure the distance field for the start state
   stomp_collision_space_.setStartState(*group, req.motion_plan_request.start_state);
 
@@ -192,9 +222,12 @@
   stomp_parameters_.setPlanningTimeLimit(req.motion_plan_request.allowed_planning_time.toSec());
 
   // optimize!
+  ros::WallTime create_time = ros::WallTime::now();
   ChompOptimizer optimizer(&trajectory, &stomp_robot_model_, group, &stomp_parameters_,
       vis_marker_array_publisher_, vis_marker_publisher_, &stomp_collision_space_);
+  ROS_INFO("Optimization took %f sec to create", (ros::WallTime::now() - create_time).toSec());
   optimizer.optimize();
+  ROS_INFO("Optimization actually took %f sec to run", (ros::WallTime::now() - create_time).toSec());
 
   // assume that the trajectory is now optimized, fill in the output structure:
 
@@ -208,7 +241,7 @@
     // try to retrieve the joint limits:
     if (joint_velocity_limits_.find(res.trajectory.joint_trajectory.joint_names[i])==joint_velocity_limits_.end())
     {
-      node_handle_.param("joint_velocity_limits/"+res.trajectory.joint_trajectory.joint_names[i], joint_velocity_limits_[res.trajectory.joint_trajectory.joint_names[i]], std::numeric_limits<double>::max());
+      joint_velocity_limits_[res.trajectory.joint_trajectory.joint_names[i]] = std::numeric_limits<double>::max();
     }
     velocity_limits[i] = joint_velocity_limits_[res.trajectory.joint_trajectory.joint_names[i]];
   }
@@ -241,6 +274,7 @@
     }
   }
 
+  ROS_INFO("Bottom took %f sec to create", (ros::WallTime::now() - create_time).toSec());
   ROS_INFO("Serviced planning request in %f wall-seconds, trajectory duration is %f", (ros::WallTime::now() - start_time).toSec(), res.trajectory.joint_trajectory.points[goal_index].time_from_start.toSec());
   return true;
 }
@@ -250,46 +284,78 @@
   ros::WallTime start_time = ros::WallTime::now();
   ROS_INFO_STREAM("Received filtering request with trajectory size " << req.trajectory.points.size());
 
-  //create a spline from the trajectory
-  spline_smoother::CubicTrajectory trajectory_solver;
-  spline_smoother::SplineTrajectory spline;
+  if(req.path_constraints.joint_constraints.size() > 0 ||
+     req.path_constraints.position_constraints.size() > 0 ||
+     req.path_constraints.orientation_constraints.size() > 0 ||
+     req.path_constraints.visibility_constraints.size() > 0) {
+    if(use_trajectory_filter_) {
+      ROS_INFO("Chomp can't handle path constraints, passing through to other trajectory filters");
+      if(!filter_trajectory_client_.call(req,res)) {
+        ROS_INFO("Pass through failed");
+      } else {
+        ROS_INFO("Pass through succeeded");
+      }
+    } else {
+      ROS_INFO("Chomp can't handle path constraints, and not set up to use additional filter");
+    }
+    return true;
+  } 
+  for (unsigned int i=0; i< req.trajectory.points.size(); i++)
+  {
+    req.trajectory.points[i].velocities.resize(req.trajectory.joint_names.size(),0.0);
+  }
 
   getLimits(req.trajectory, req.limits);
 
-  for (unsigned int i=0; i< req.trajectory.points.size(); i++)
-  {
-    req.trajectory.points[i].velocities.resize(req.trajectory.joint_names.size());
+  trajectory_msgs::JointTrajectory jtraj;
+
+  int num_points = req.trajectory.points.size();
+  if(num_points > maximum_spline_points_) {
+    num_points = maximum_spline_points_;
+  } else if(num_points < minimum_spline_points_) {
+    num_points = minimum_spline_points_;
   }
 
-  bool success = trajectory_solver.parameterize(req.trajectory,req.limits,spline);  
-
+  //create a spline from the trajectory
+  spline_smoother::CubicTrajectory trajectory_solver;
+  spline_smoother::SplineTrajectory spline;
+  
+  trajectory_solver.parameterize(req.trajectory,req.limits,spline);  
+  
   double smoother_time;
   spline_smoother::getTotalTime(spline, smoother_time);
   
-  ROS_INFO_STREAM("Total time is " << smoother_time);
-
-  unsigned int NUM_POINTS=100;
-
+  ROS_INFO_STREAM("Total time given is " << smoother_time);
+  
   double t = 0.0;
-  std::vector<double> times(NUM_POINTS);
-  for(unsigned int i = 0; i < NUM_POINTS; i++,t += smoother_time/(1.0*NUM_POINTS)) {
+  std::vector<double> times(num_points);
+  for(int i = 0; i < num_points; i++,t += smoother_time/(1.0*(num_points-1))) {
     times[i] = t;
   }
-
-  trajectory_msgs::JointTrajectory jtraj;
+    
   spline_smoother::sampleSplineTrajectory(spline, times, jtraj);
-
-  double planner_time = req.trajectory.points.back().time_from_start.toSec();
   
+  //double planner_time = req.trajectory.points.back().time_from_start.toSec();
+  
   t = 0.0;
-  for(unsigned int i = 0; i < jtraj.points.size(); i++, t += planner_time/(1.0*NUM_POINTS)) {
+  for(unsigned int i = 0; i < jtraj.points.size(); i++, t += smoother_time/(1.0*(num_points-1))) {
     jtraj.points[i].time_from_start = ros::Duration(t);
   }
-
+  
   ROS_INFO_STREAM("Sampled trajectory has " << jtraj.points.size() << " points with " << jtraj.points[0].positions.size() << " joints");
 
+  //TODO - match joints in the trajectory to planning group name
+  std::string group_name;
+  if(req.trajectory.joint_names[0].at(0) == 'r') {
+    group_name = "right_arm";
+  } else if(req.trajectory.joint_names[0].at(0) == 'l') {
+    group_name="left_arm";
+  } else {
+    ROS_INFO_STREAM("Joint names don't seem to correspond to left or right arm");
+  }
+
   // get the filter group - will need to figure out
-  const ChompRobotModel::ChompPlanningGroup* group = stomp_robot_model_.getPlanningGroup("right_arm");
+  const ChompRobotModel::ChompPlanningGroup* group = stomp_robot_model_.getPlanningGroup(group_name);
 
   if (group==NULL)
   {
@@ -301,31 +367,9 @@
 
   //configure the distance field - this should just use current state
   motion_planning_msgs::RobotState robot_state;
-  robot_state.joint_state.position.clear();
-  robot_state.joint_state.name.clear();
-  planning_models::KinematicState sp(*(monitor_->getRobotState()));
-  // boost::scoped_ptr<planning_models::KinematicState> sp(new planning_models::KinematicState(getKinematicModel()));
-  // fill in robot state with current one
-  std::vector<const planning_models::KinematicModel::Joint*> joints;
-  monitor_->getKinematicModel()->getJoints(joints);
-	    
-  robot_state.joint_state.name.resize(joints.size());
-  robot_state.joint_state.position.resize(joints.size());
-  robot_state.joint_state.header.frame_id = reference_frame_;
-  robot_state.joint_state.header.stamp = monitor_->lastJointStateUpdate();
+  monitor_->getCurrentRobotState(robot_state);
 
-  for (unsigned int i = 0 ; i < joints.size() ; ++i)
-  {
-    robot_state.joint_state.name[i] = joints[i]->name;
-    std::vector<double> tmp;
-    sp.copyParamsJoint(tmp, joints[i]->name);
-    if(!tmp.empty())
-      robot_state.joint_state.position[i] = tmp[0];
-  }
-
-  // set the start state:
   stomp_robot_model_.jointStateToArray(robot_state.joint_state, trajectory.getTrajectoryPoint(0));
-
   stomp_collision_space_.setStartState(*group, robot_state);
 
   //updating collision points for the potential for new attached objects
@@ -334,8 +378,8 @@
   stomp_robot_model_.generateAttachedObjectCollisionPoints(&(robot_state));
   stomp_robot_model_.populatePlanningGroupCollisionPoints();
 
-  // set the goal state equal to start state, and override the joints specified in the goal
-  // joint constraints
+  //set the goal state equal to start state, and override the joints specified in the goal
+  //joint constraints
   int goal_index = trajectory.getNumPoints()-1;
   trajectory.getTrajectoryPoint(goal_index) = trajectory.getTrajectoryPoint(0);
 
@@ -354,12 +398,26 @@
       trajectory(goal_index, kdl_index) = start + angles::shortest_angular_distance(start, end);
     }
   }
-
+  /*
+    for(int i = 0; i < trajectory.getNumPoints(); i++) {
+    
+    ROS_INFO_STREAM(trajectory(i,group->stomp_joints_[0].kdl_joint_index_) << " " <<
+    trajectory(i,group->stomp_joints_[1].kdl_joint_index_) << " " <<
+    trajectory(i,group->stomp_joints_[2].kdl_joint_index_) << " " <<
+    trajectory(i,group->stomp_joints_[3].kdl_joint_index_) << " " <<
+    trajectory(i,group->stomp_joints_[4].kdl_joint_index_) << " " <<
+    trajectory(i,group->stomp_joints_[5].kdl_joint_index_) << " " <<
+    trajectory(i,group->stomp_joints_[6].kdl_joint_index_) << " ");
+    }
+  ROS_INFO_STREAM("Duration is " << trajectory.getDuration());
+  */
+  //sets other joints
+  trajectory.fillInMinJerk();
+  trajectory.overwriteTrajectory(jtraj);
+  
   // set the max planning time:
   stomp_parameters_.setPlanningTimeLimit(req.allowed_time.toSec());
   
-  ROS_INFO("Calling optimizer");
-
   // optimize!
   ChompOptimizer optimizer(&trajectory, &stomp_robot_model_, group, &stomp_parameters_,
       vis_marker_array_publisher_, vis_marker_publisher_, &stomp_collision_space_);
@@ -403,26 +461,35 @@
         if (d > duration)
           duration = d;
       }
-      res.trajectory.points[i].time_from_start = res.trajectory.points[i-1].time_from_start + ros::Duration(duration);
+      try {
+        res.trajectory.points[i].time_from_start = res.trajectory.points[i-1].time_from_start + ros::Duration(duration);
+      } catch(...) {
+        ROS_INFO_STREAM("Potentially weird duration of " << duration);
+      }
     }
   }
+  motion_planning_msgs::FilterJointTrajectoryWithConstraints::Request  next_req;
+  motion_planning_msgs::FilterJointTrajectoryWithConstraints::Response next_res;
 
-//   motion_planning_msgs::FilterJointTrajectoryWithConstraints::Request  next_req;
-//   motion_planning_msgs::FilterJointTrajectoryWithConstraints::Response next_res;
-  
-//   next_req = req;
-//   next_req.trajectory = res.trajectory;
-  
-//   ROS_INFO("Trying to make call");
+  if(use_trajectory_filter_) {
+    next_req = req;
+    next_req.trajectory = res.trajectory;  
+    next_req.allowed_time=ros::Duration(1.0);//req.allowed_time/2.0;
+    
+    if(filter_trajectory_client_.call(next_req, next_res)) {
+      ROS_INFO_STREAM("Filter call ok. Sent trajectory had " << res.trajectory.points.size() << " points.  Returned trajectory has " << next_res.trajectory.points.size() << " points ");
+    } else {
+      ROS_INFO("Filter call not ok");
+    }
+    
+    res.trajectory = next_res.trajectory;
+    res.error_code = next_res.error_code;
+    res.trajectory.header.stamp = ros::Time::now();
+    res.trajectory.header.frame_id = reference_frame_;
+  } else {
+    res.error_code.val = res.error_code.val = res.error_code.SUCCESS;
+  }
 
-//   if(filter_trajectory_client_.call(next_req, next_res)) {
-//     ROS_INFO("Filter call ok");
-//   } else {
-//     ROS_INFO("Filter call not ok");
-//   }
-
-//   res = next_res;
-
   // for every point in time:
   for (unsigned int i=1; i<res.trajectory.points.size()-1; ++i)
   {
@@ -486,13 +553,13 @@
 {
   ros::init(argc, argv, "stomp_planner_node");
 
-  ros::AsyncSpinner spinner(1); // Use 1 thread
-  spinner.start();
+  //ros::AsyncSpinner spinner(1); // Use 1 thread
+  //spinner.start();
 
   ros::NodeHandle node_handle("~");
   stomp::ChompPlannerNode stomp_planner_node(node_handle);
   if (!stomp_planner_node.init())
     return 1;
-  ros::waitForShutdown();
-  //return stomp_planner_node.run();
+  return stomp_planner_node.run();
+  //ros::waitForShutdown();
 }
Index: src/stomp_robot_model.cpp
===================================================================
--- src/stomp_robot_model.cpp	(.../cturtle/stomp_motion_planner)	(revision 50636)
+++ src/stomp_robot_model.cpp	(.../diamondback/stomp_motion_planner)	(revision 50636)
@@ -38,6 +38,8 @@
 #include <kdl_parser/kdl_parser.hpp>
 #include <ros/ros.h>
 #include <cstdio>
+#include <iostream>
+#include <visualization_msgs/MarkerArray.h>
 
 using namespace std;
 using namespace mapping_msgs;
@@ -153,20 +155,24 @@
         joint.link_name_ = link_name;
         joint.joint_name_ = segment_joint_mapping_[link_name];
         joint.joint_update_limit_ = joint_update_limit;
-        planning_models::KinematicModel::Joint* kin_model_joint = monitor_->getCollisionModels()->getKinematicModel()->getJoint(joint.joint_name_);
-        if (planning_models::KinematicModel::RevoluteJoint* revolute_joint = dynamic_cast<planning_models::KinematicModel::RevoluteJoint*>(kin_model_joint))
+        const planning_models::KinematicModel::JointModel* kin_model_joint = monitor_->getCollisionModels()->getKinematicModel()->getJointModel(joint.joint_name_);
+        if (const planning_models::KinematicModel::RevoluteJointModel* revolute_joint = dynamic_cast<const planning_models::KinematicModel::RevoluteJointModel*>(kin_model_joint))
         {
-          joint.wrap_around_ = revolute_joint->continuous;
+          joint.wrap_around_ = revolute_joint->continuous_;
           joint.has_joint_limits_ = !(joint.wrap_around_);
-          joint.joint_limit_min_ = revolute_joint->lowLimit;
-          joint.joint_limit_max_ = revolute_joint->hiLimit;
+          std::pair<double,double> bounds = revolute_joint->getVariableBounds(revolute_joint->getName());
+          joint.joint_limit_min_ = bounds.first;
+          joint.joint_limit_max_ = bounds.second;
+          ROS_DEBUG_STREAM("Setting bounds for joint " << revolute_joint->getName() << " to " << joint.joint_limit_min_ << " " << joint.joint_limit_max_);
         }
-        else if (planning_models::KinematicModel::PrismaticJoint* prismatic_joint = dynamic_cast<planning_models::KinematicModel::PrismaticJoint*>(kin_model_joint))
+        else if (const planning_models::KinematicModel::PrismaticJointModel* prismatic_joint = dynamic_cast<const planning_models::KinematicModel::PrismaticJointModel*>(kin_model_joint))
         {
           joint.wrap_around_ = false;
           joint.has_joint_limits_ = true;
-          joint.joint_limit_min_ = prismatic_joint->lowLimit;
-          joint.joint_limit_max_ = prismatic_joint->hiLimit;
+          std::pair<double,double> bounds = prismatic_joint->getVariableBounds(prismatic_joint->getName());
+          joint.joint_limit_min_ = bounds.first;
+          joint.joint_limit_max_ = bounds.second;
+          ROS_DEBUG_STREAM("Setting bounds for joint " << prismatic_joint->getName() << " to " << joint.joint_limit_min_ << " " << joint.joint_limit_max_);
         }
         else
         {
@@ -254,15 +260,33 @@
 
 }
 
-void ChompRobotModel::addCollisionPointsFromLinkRadius(std::string link_name, double radius, double clearance, double extension)
+void ChompRobotModel::addCollisionPointsFromLink(const planning_models::KinematicState& state, std::string link_name, double clearance)
 {
+  const planning_models::KinematicState::LinkState* link_state = state.getLinkState(link_name);
+  if(link_state == NULL) {
+    ROS_WARN_STREAM("Collision link " << link_name << " not valid");
+    return;
+  }
+
+  bodies::Body* body = bodies::createBodyFromShape(link_state->getLinkModel()->getLinkShape());
+  body->setPadding(monitor_->getEnvironmentModel()->getCurrentLinkPadding(link_state->getName()));
+  body->setPose(link_state->getGlobalLinkTransform());
+  body->setScale(1.0);
+  bodies::BoundingCylinder cyl;
+  body->computeBoundingCylinder(cyl);
+  delete body;
+
   std::vector<int> active_joints;
   KDL::SegmentMap::const_iterator segment_iter = kdl_tree_.getSegment(link_name);
   int segment_number;
 
+  ROS_DEBUG_STREAM("Link " << link_name << " length " << cyl.length << " radius " << cyl.radius);
+
   getLinkInformation(link_name, active_joints, segment_number);
   std::vector<ChompCollisionPoint>& collision_points_vector = link_collision_points_.find(link_name)->second;
 
+  
+
   int first_child=1;
   // find the child:
   for (std::vector<KDL::SegmentMap::const_iterator>::const_iterator child_iter = segment_iter->second.children.begin();
@@ -274,9 +298,9 @@
     ROS_DEBUG("joint origin for %s is %f %f %f\n", (*child_iter)->first.c_str(), joint_origin.x(), joint_origin.y(), joint_origin.z());
 
     // generate equidistant collision points for this link:
-    double spacing = radius/2.0;
+    double spacing = cyl.radius;
     double distance = joint_origin.Norm();
-    distance+=extension;
+    distance+=cyl.length;
     int num_points = ceil(distance/spacing)+1;
     spacing = distance/(num_points-1.0);
 
@@ -286,8 +310,11 @@
       if (!first_child && i==0)
         continue;
       point_pos = joint_origin * (double)(i/(num_points-1.0));
-      collision_points_vector.push_back(ChompCollisionPoint(active_joints, radius, clearance, segment_number, point_pos));
+      collision_points_vector.push_back(ChompCollisionPoint(active_joints, cyl.radius, clearance, segment_number, point_pos));
       ROS_DEBUG_STREAM("Point pos is " << point_pos.x() << " " << point_pos.y() << " " << point_pos.z());
+      if(max_radius_clearance_ < cyl.radius) {
+        max_radius_clearance_ = cyl.radius+clearance;
+      }
     }
 
     first_child = 0;
@@ -344,26 +371,33 @@
   // clear out link collision points:
   link_collision_points_.clear();
 
-  // iterate over all collision checking links to add collision points
-  for (vector<string>::const_iterator link_it=monitor_->getCollisionModels()->getGroupLinkUnion().begin();
-      link_it!=monitor_->getCollisionModels()->getGroupLinkUnion().end(); ++link_it)
-  {
-    // get the "radius" of this link from the param server, if any:
-    double link_radius;
-    std::string link_name = *link_it;
-    std::string link_param_root = "collision_links/"+link_name+"/";
-    if (node_handle_.getParam(link_param_root+"link_radius", link_radius))
-    {
-      double clearance;
-      double extension;
-      node_handle_.param(link_param_root+"link_clearance", clearance, collision_clearance_default_);
-      node_handle_.param(link_param_root+"link_extension", extension, 0.0);
-      addCollisionPointsFromLinkRadius(link_name, link_radius, clearance, extension);
-      double new_max_rc = link_radius + clearance;
-      if (max_radius_clearance_ < new_max_rc)
-        max_radius_clearance_ = new_max_rc;
-    }
+  if(!node_handle_.hasParam("collision_links")) {
+    ROS_WARN_STREAM("No collision link param specified");
+    return;
+  } 
+
+  std::string all_links_string;
+
+  node_handle_.getParam("collision_links", all_links_string);
+
+  std::list<std::string> all_links_list;
+
+  std::stringstream link_name_stream(all_links_string);
+  while(link_name_stream.good() && !link_name_stream.eof()){
+    std::string lname;
+    link_name_stream >> lname;
+    if(lname.size() == 0) continue;
+    all_links_list.push_back(lname);
   }
+
+  planning_models::KinematicState state(monitor_->getKinematicModel());
+  monitor_->setStateValuesFromCurrentValues(state);
+  
+  for(std::list<std::string>::iterator it = all_links_list.begin();
+      it != all_links_list.end();
+      it++) {
+    addCollisionPointsFromLink(state, *it, collision_clearance_default_);
+  }
 }
 
 void ChompRobotModel::generateAttachedObjectCollisionPoints(const motion_planning_msgs::RobotState* robot_state) {
@@ -372,25 +406,17 @@
     ROS_ERROR("Must have robot state to generate collision points from attached objects");
     return;
   }
+
+  planning_models::KinematicState state(monitor_->getKinematicModel());
+
+  monitor_->setRobotStateAndComputeTransforms(*robot_state, state);
   
-  monitor_->getEnvironmentModel()->lock();
-  monitor_->getKinematicModel()->lock();
+  //get rid of root transform
+  btTransform id;
+  id.setIdentity();
+  state.getJointState(monitor_->getKinematicModel()->getRoot()->getName())->setJointStateValues(id);
+  state.updateKinematicLinks();
   
-  planning_models::KinematicState *state = new planning_models::KinematicState(*(monitor_->getRobotState()));
-  
-  std::vector<double> tmp;
-  tmp.resize(1);
-  for (unsigned int i = 0 ; i < robot_state->joint_state.position.size() ; ++i)
-  {
-    tmp[0] = robot_state->joint_state.position[i];
-    state->setParamsJoint(tmp, robot_state->joint_state.name[i]);
-  }
-  
-  // figure out the poses of the robot model
-  monitor_->getKinematicModel()->computeTransforms(state->getParams());
-  // update the collision space
-  monitor_->getEnvironmentModel()->updateRobotModel();
-  
   // iterate over all collision checking links to add collision points
   for (vector<string>::const_iterator link_it=monitor_->getCollisionModels()->getGroupLinkUnion().begin();
        link_it!=monitor_->getCollisionModels()->getGroupLinkUnion().end(); ++link_it)
@@ -404,21 +430,21 @@
 
     collision_points_vector.clear();
 
-    const std::vector<const planning_models::KinematicModel::AttachedBody*> att_vec = monitor_->getEnvironmentModel()->getAttachedBodies();
+    const std::vector<const planning_models::KinematicState::AttachedBodyState*>& att_vec = state.getAttachedBodyStateVector();
     for(unsigned int i = 0; i < att_vec.size(); i++) 
     {
-      if(link_name ==  att_vec[i]->owner->name) 
+      if(link_name ==  att_vec[i]->getAttachedLinkName()) 
       {
         if(robot_state != NULL) {
-          const unsigned int n = att_vec[i]->shapes.size();
+          const unsigned int n = att_vec[i]->getAttachedBodyModel()->getShapes().size();
           for(unsigned int j = 0; j < n; j++) {
-            bodies::Body *body = bodies::createBodyFromShape(att_vec[i]->shapes[j]);          
+            bodies::Body *body = bodies::createBodyFromShape(att_vec[i]->getAttachedBodyModel()->getShapes()[j]);          
             body->setPadding(monitor_->getEnvironmentModel()->getCurrentLinkPadding("attached"));
             
             geometry_msgs::PoseStamped pose_global;
             pose_global.header.stamp = robot_state->joint_state.header.stamp;
             pose_global.header.frame_id = reference_frame_;
-            tf::poseTFToMsg(att_vec[i]->globalTrans[j], pose_global.pose);
+            tf::poseTFToMsg(att_vec[i]->getGlobalCollisionBodyTransforms()[j], pose_global.pose);
             
             geometry_msgs::PoseStamped pose_link;
             monitor_->getTransformListener()->transformPose(link_name, pose_global, pose_link);
@@ -428,20 +454,34 @@
 
             body->setPose(pose);
             ROS_INFO_STREAM("Should have a padding of " << monitor_->getEnvironmentModel()->getCurrentLinkPadding("attached"));
-            bodies::BoundingSphere bounding_sphere;
-            body->computeBoundingSphere(bounding_sphere);
-            KDL::Vector position(bounding_sphere.center.x(),bounding_sphere.center.y(),bounding_sphere.center.z());
-            ROS_INFO_STREAM("Setting position " << bounding_sphere.center.x() << " " << bounding_sphere.center.y() << " " << bounding_sphere.center.z());
-            ROS_INFO_STREAM("Adding bounding sphere of radius " << bounding_sphere.radius << " to link " << link_name);
-            collision_points_vector.push_back(ChompCollisionPoint(active_joints, bounding_sphere.radius, collision_clearance_default_, segment_number, position));
+            bodies::BoundingCylinder bounding_cylinder;
+            body->computeBoundingCylinder(bounding_cylinder);
+
+	    KDL::Rotation rotation = KDL::Rotation::Quaternion(pose_link.pose.orientation.x,
+							       pose_link.pose.orientation.y,
+							       pose_link.pose.orientation.z,
+							       pose_link.pose.orientation.w);
+	    KDL::Vector position(pose_link.pose.position.x, pose_link.pose.position.y, pose_link.pose.position.z);
+	    KDL::Frame f(rotation, position);    
+	    // generate points:
+	    double radius = bounding_cylinder.radius;
+	    double length = bounding_cylinder.length;
+	    KDL::Vector p(0,0,0);
+	    KDL::Vector p2;
+	    double spacing = radius/2.0;
+	    int num_points = ceil(length/spacing)+1;
+	    spacing = length/(num_points-1.0);
+	    for (int i=0; i<num_points; ++i) {
+	      p(2) = -length/2.0 + i*spacing;
+	      p2 = f*p;
+	      collision_points_vector.push_back(ChompCollisionPoint(active_joints, radius, collision_clearance_default_, segment_number, p2));
+	    }
             delete body;
           }
         }
       }
     }
   }
-  monitor_->getEnvironmentModel()->unlock();
-  monitor_->getKinematicModel()->unlock();
 }
 
 void ChompRobotModel::populatePlanningGroupCollisionPoints() {
Index: src/stomp_collision_space.cpp
===================================================================
--- src/stomp_collision_space.cpp	(.../cturtle/stomp_motion_planner)	(revision 50636)
+++ src/stomp_collision_space.cpp	(.../diamondback/stomp_motion_planner)	(revision 50636)
@@ -80,7 +80,7 @@
 
   //initCollisionCuboids();
 
-  distance_field_ = new distance_field::PropagationDistanceField(size_x, size_y, size_z, resolution, origin_x, origin_y, origin_z, max_expansion_);
+  distance_field_ = new distance_field::PropagationDistanceField(size_x, size_y, size_z, resolution, origin_x, origin_y, origin_z, max_radius_clearance);
 
   monitor_ = monitor;
   //now setting up robot bodies for potential inclusion in the distance field
@@ -111,7 +111,23 @@
           std::string object2 = std::string(coll_ops[i]["object2"]);
           std::string operation = std::string(coll_ops[i]["operation"]);
           if(operation == "enable") {
-            ROS_WARN("Chomp doesn't support enabling collisions");
+            if(planning_group_link_names_.find(object1) == planning_group_link_names_.end()) {
+              ROS_WARN_STREAM("Object 1 must be a recognized planning group and " << object1 << " is not");
+              continue;
+            }
+            if(distance_include_links_.find(object1) == distance_include_links_.end()) {
+              std::vector<std::string> emp;
+              distance_include_links_[object1] = emp;
+            }
+            std::vector<std::string>& include_links = distance_include_links_[object1];
+            if(planning_group_link_names_.find(object2) == planning_group_link_names_.end()) {
+              include_links.push_back(object2);
+              ROS_DEBUG_STREAM("Link " << object1 << " adding include for link " << object2);
+            } else {
+              ROS_DEBUG_STREAM("Link " << object1 << " adding include for group " << object2 << " size " << planning_group_link_names_.find(object2)->second.size() );
+              include_links.insert(include_links.end(), planning_group_link_names_.find(object2)->second.begin(),
+                                   planning_group_link_names_.find(object2)->second.end());
+            }
           } else if(operation == "disable") {
             if(planning_group_link_names_.find(object1) == planning_group_link_names_.end()) {
               ROS_WARN_STREAM("Object 1 must be a recognized planning group and " << object1 << " is not");
@@ -124,9 +140,9 @@
             std::vector<std::string>& exclude_links = distance_exclude_links_[object1];
             if(planning_group_link_names_.find(object2) == planning_group_link_names_.end()) {
               exclude_links.push_back(object2);
-              ROS_INFO_STREAM("Link " << object1 << " adding exclude for link " << object2);
+              ROS_DEBUG_STREAM("Link " << object1 << " adding exclude for link " << object2);
             } else {
-              ROS_INFO_STREAM("Link " << object1 << " adding exclude for group " << object2 << " size " << planning_group_link_names_.find(object2)->second.size() );
+              ROS_DEBUG_STREAM("Link " << object1 << " adding exclude for group " << object2 << " size " << planning_group_link_names_.find(object2)->second.size() );
               exclude_links.insert(exclude_links.end(), planning_group_link_names_.find(object2)->second.begin(),
                                    planning_group_link_names_.find(object2)->second.end());
             }
@@ -157,46 +173,49 @@
 
   monitor_->waitForState();
 
+  planning_models::KinematicState state(monitor_->getKinematicModel());
+
   distance_field_->reset();
 
   std::vector<btVector3> all_points;
 
   monitor_->getEnvironmentModel()->lock();
-  monitor_->getKinematicModel()->lock();
+  monitor_->setRobotStateAndComputeTransforms(robot_state, state);
 
-  planning_models::KinematicState state(planning_models::KinematicState(*(monitor_->getRobotState())));
+  monitor_->setCollisionSpace();
+  
+  std::string root_name = monitor_->getKinematicModel()->getRoot()->getName();
 
-  std::vector<double> tmp;
-  tmp.resize(1);
-  for (unsigned int i = 0 ; i < robot_state.joint_state.position.size() ; ++i)
-  {
-    tmp[0] = robot_state.joint_state.position[i];
-    state.setParamsJoint(tmp, robot_state.joint_state.name[i]);
-  }
+  //now we need to back out this transform
+  const btTransform& cur = state.getJointState(root_name)->getVariableTransform();
+  btTransform cur_copy(cur);
+  
+  //now get the body in the identity transform
+  btTransform id;
+  id.setIdentity();
+  state.getJointState(root_name)->setJointStateValues(id);
+  state.updateKinematicLinks();
 
-  // figure out the poses of the robot model
-  monitor_->getKinematicModel()->computeTransforms(state.getParams());
-  // update the collision space
-  monitor_->getEnvironmentModel()->updateRobotModel();
+  updateRobotBodiesPoses(state);
 
-  updateRobotBodiesPoses();
-
   addAllBodiesButExcludeLinksToPoints(planning_group.name_, all_points);
-  addCollisionObjectsToPoints(all_points);
+  addCollisionObjectsToPoints(all_points, cur_copy);
 
   ROS_INFO_STREAM("All points size " << all_points.size());
   
   distance_field_->addPointsToField(all_points);
-  distance_field_->visualize(0.0*max_expansion_, 0.01*max_expansion_, reference_frame_, ros::Time::now());
+  distance_field_->visualize(0.0*max_expansion_, 0.01*max_expansion_, monitor_->getWorldFrameId(), cur_copy, ros::Time::now());
 
-  monitor_->getKinematicModel()->unlock();
-  monitor_->getEnvironmentModel()->unlock();  
+  monitor_->getEnvironmentModel()->unlock();
 
   ros::WallDuration t_diff = ros::WallTime::now() - start;
   ROS_INFO_STREAM("Took " << t_diff.toSec() << " to set distance field");
 }
 
-void ChompCollisionSpace::addCollisionObjectsToPoints(std::vector<btVector3>& points) {  
+void ChompCollisionSpace::addCollisionObjectsToPoints(std::vector<btVector3>& points, const btTransform& cur_transform) {  
+
+  btTransform inv = cur_transform.inverse();
+
   const collision_space::EnvironmentObjects *eo = monitor_->getEnvironmentModel()->getObjects();
   std::vector<std::string> ns = eo->getNamespaces();
   for (unsigned int i = 0 ; i < ns.size() ; ++i)
@@ -209,14 +228,14 @@
       //points.reserve(points.size()+n);
       for(unsigned int j = 0; j < n;  ++j) 
       {
-        points.push_back(no.shapePose[j].getOrigin());
+        points.push_back(inv*no.shapePose[j].getOrigin());
       }
       continue;
     }
     for(unsigned int j = 0; j < n; j++) {
       if (no.shape[j]->type == shapes::MESH) {
         bodies::Body *body = bodies::createBodyFromShape(no.shape[j]);
-        body->setPose(no.shapePose[j]);
+        body->setPose(inv*no.shapePose[j]);
         std::vector<btVector3> body_points;
         getVoxelsInBody(*body, body_points);
         points.insert(points.end(), body_points.begin(), body_points.end());
@@ -264,7 +283,7 @@
                   KDL::Vector p(pose.position.x-x,pose.position.y-y,pose.position.z-z);                  
                   KDL::Vector p2;
                   p2 = f*p;
-                  points.push_back(btVector3(p2(0),p2(1),p2(2)));
+                  points.push_back(inv*btVector3(p2(0),p2(1),p2(2)));
                 }
               }
             }
@@ -286,7 +305,7 @@
                 KDL::Vector p(pose.position.x-x,pose.position.y-y,pose.position.z-z);                  
                 KDL::Vector p2;
                 p2 = f*p;
-                points.push_back(btVector3(p2(0),p2(1),p2(2)));
+                points.push_back(inv*btVector3(p2(0),p2(1),p2(2)));
               }
             }
           }
@@ -497,20 +516,20 @@
 
   planning_group_link_names_ = monitor_->getCollisionModels()->getPlanningGroupLinks();
 
-  ROS_INFO_STREAM("Planning group links size " << planning_group_link_names_.size());
+  ROS_DEBUG_STREAM("Planning group links size " << planning_group_link_names_.size());
 
   for(std::map<std::string, std::vector<std::string> >::iterator it1 = planning_group_link_names_.begin();
       it1 != planning_group_link_names_.end();
       it1++)
   {
-    ROS_INFO_STREAM("Chomp loading group " << it1->first);
+    ROS_DEBUG_STREAM("Chomp loading group " << it1->first);
 
     for(std::vector<std::string>::iterator it2 = it1->second.begin();
         it2 != it1->second.end();
         it2++) {
-      const planning_models::KinematicModel::Link* link = monitor_->getCollisionModels()->getKinematicModel()->getLink(*it2);
+      const planning_models::KinematicModel::LinkModel* link = monitor_->getCollisionModels()->getKinematicModel()->getLinkModel(*it2);
       if(link != NULL) {
-        planning_group_bodies_[it1->first].push_back(bodies::createBodyFromShape(link->shape));
+        planning_group_bodies_[it1->first].push_back(bodies::createBodyFromShape(link->getLinkShape()));
       } else {
         ROS_WARN_STREAM("Error - no link for name " << *it2);
       }
@@ -519,16 +538,13 @@
   }
 }
 
-void ChompCollisionSpace::updateRobotBodiesPoses() {
-  monitor_->getKinematicModel()->computeTransforms(monitor_->getRobotState()->getParams());
-
+void ChompCollisionSpace::updateRobotBodiesPoses(const planning_models::KinematicState& state) {
   for(std::map<std::string, std::vector<bodies::Body *> >::iterator it1 = planning_group_bodies_.begin();
       it1 != planning_group_bodies_.end();
       it1++) {
     std::vector<std::string>& v = planning_group_link_names_[it1->first];
     for(unsigned int i = 0; i < it1->second.size(); i++) {
-      const planning_models::KinematicModel::Link* link = monitor_->getKinematicModel()->getLink(v[i]);
-      (it1->second)[i]->setPose(link->globalTransFwd);
+      (it1->second)[i]->setPose(state.getLinkState(v[i])->getGlobalLinkTransform());
     }
   }
 }
@@ -542,7 +558,7 @@
       for(unsigned int i = 0; i < it1->second.size(); i++) {
         std::vector<btVector3> single_body_points;
         getVoxelsInBody((*it1->second[i]), single_body_points);
-        ROS_INFO_STREAM("Group " << it1->first << " link num " << i << " points " << single_body_points.size());
+        ROS_DEBUG_STREAM("Group " << it1->first << " link num " << i << " points " << single_body_points.size());
         body_points.insert(body_points.end(), single_body_points.begin(), single_body_points.end());
       }
     }
@@ -552,7 +568,7 @@
       for(unsigned int i = 0; i < bodies.size(); i++) {
         std::vector<btVector3> single_body_points;
         getVoxelsInBody(*(bodies[i]), single_body_points);
-        ROS_INFO_STREAM("Group " << group << " link num " << i << " points " << single_body_points.size());
+        ROS_DEBUG_STREAM("Group " << group << " link num " << i << " points " << single_body_points.size());
         body_points.insert(body_points.end(), single_body_points.begin(), single_body_points.end());
       }
     } else {
@@ -569,6 +585,18 @@
     exclude_links = distance_exclude_links_[group_name];
   }
 
+  //now go through include and see if we have to add anything back
+  if(distance_include_links_.find(group_name) != distance_include_links_.end()) {
+    for(std::vector<std::string>::iterator it = distance_include_links_[group_name].begin();
+        it != distance_include_links_[group_name].end();
+        it++) {
+      std::vector<std::string>::iterator f = find(exclude_links.begin(), exclude_links.end(), *it);
+      if(f != exclude_links.end()) {
+        exclude_links.erase(f);
+      }
+    }
+  }
+
   for(std::map<std::string, std::vector<bodies::Body *> >::iterator it1 = planning_group_bodies_.begin();
       it1 != planning_group_bodies_.end();
       it1++) {
@@ -578,7 +606,7 @@
       if(find(exclude_links.begin(), exclude_links.end(),group_link_names[i]) == exclude_links.end()) {
         std::vector<btVector3> single_body_points;
         getVoxelsInBody((*it1->second[i]), single_body_points);
-        //ROS_INFO_STREAM("Group " << it1->first << " link " << group_link_names[i] << " points " << single_body_points.size());
+        ROS_DEBUG_STREAM("Group " << it1->first << " link " << group_link_names[i] << " points " << single_body_points.size());
         body_points.insert(body_points.end(), single_body_points.begin(), single_body_points.end());
       }
     }
Index: src/stomp_trajectory.cpp
===================================================================
--- src/stomp_trajectory.cpp	(.../cturtle/stomp_motion_planner)	(revision 50636)
+++ src/stomp_trajectory.cpp	(.../diamondback/stomp_motion_planner)	(revision 50636)
@@ -123,9 +123,7 @@
   }
   discretization_ = discretization;
 
-  ROS_INFO_STREAM("Num planning joints " << planning_group_->num_joints_ << " num trajectory joints " << traj.joint_names.size());
-  
-  num_points_ = traj.points.size();
+  num_points_ = traj.points.size()+1;
   duration_ = (traj.points.back().time_from_start-traj.points[0].time_from_start).toSec();
   
   start_index_ = 1;
@@ -133,12 +131,19 @@
 
   init();
 
-  for(unsigned int i = 0; i < num_points_; i++) {
-    for(unsigned int j = 0; j < num_joints_; j++) {
+  for(int i = 0; i < num_points_; i++) {
+    for(int j = 0; j < num_joints_; j++) {
       trajectory_(i,j) = 0.0;
     }
   }
+  overwriteTrajectory(traj);
+}
 
+ChompTrajectory::~ChompTrajectory()
+{
+}
+
+void ChompTrajectory::overwriteTrajectory(const trajectory_msgs::JointTrajectory& traj) {
   std::vector<int> ind;
   for(unsigned int j = 0; j < traj.joint_names.size(); j++) {
     int kdl_number = robot_model_->urdfNameToKdlNumber(traj.joint_names[j]);
@@ -148,17 +153,13 @@
     ind.push_back(kdl_number);
   }
 
-  for(unsigned int i = 0; i < traj.points.size(); i++) {
+  for(unsigned int i = 1; i <= traj.points.size(); i++) {
     for(unsigned int j = 0; j < traj.joint_names.size(); j++) {
-      trajectory_(i,ind[j]) = traj.points[i].positions[j];
+      trajectory_(i,ind[j]) = traj.points[i-1].positions[j];
     }
   }  
 }
 
-ChompTrajectory::~ChompTrajectory()
-{
-}
-
 void ChompTrajectory::init()
 {
   //trajectory_.resize(num_points_, Eigen::VectorXd(num_joints_));

Property changes on: .
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /stacks/motion_planners/branches/generic_kinematics/stomp_motion_planner:r49785-49804
   Merged /stacks/motion_planners/branches/multidof/stomp_motion_planner:r42386-43547
   Merged /stacks/motion_planners/branches/multidof2/stomp_motion_planner:r45166-45493
   Merged /stacks/motion_planners/branches/ompl_fix/stomp_motion_planner:r42580

